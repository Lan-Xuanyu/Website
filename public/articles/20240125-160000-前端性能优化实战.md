---
title: 前端性能优化实战
date: 2024-01-25
---

前端性能优化是提升用户体验的关键因素。本文将介绍一些实用的前端性能优化技巧和最佳实践。

## 加载性能优化

### 1. 代码分割（Code Splitting）

使用动态导入来实现代码分割，减少初始包大小：

```javascript
// 路由级别的代码分割
const Home = lazy(() => import('./pages/Home'));
const About = lazy(() => import('./pages/About'));

function App() {
  return (
    <Router>
      <Suspense fallback={<div>加载中...</div>}>
        <Routes>
          <Route path="/" element={<Home />} />
          <Route path="/about" element={<About />} />
        </Routes>
      </Suspense>
    </Router>
  );
}
```

### 2. 资源预加载

```html
<!-- DNS 预解析 -->
<link rel="dns-prefetch" href="//example.com">

<!-- 预加载关键资源 -->
<link rel="preload" href="/critical.css" as="style">
<link rel="preload" href="/hero-image.jpg" as="image">

<!-- 预获取下一页面资源 -->
<link rel="prefetch" href="/next-page.js">
```

### 3. 图片优化

```jsx
// 使用现代图片格式
function OptimizedImage({ src, alt }) {
  return (
    <picture>
      <source srcSet={`${src}.webp`} type="image/webp" />
      <source srcSet={`${src}.avif`} type="image/avif" />
      <img src={`${src}.jpg`} alt={alt} loading="lazy" />
    </picture>
  );
}
```

## 运行时性能优化

### 1. 虚拟化长列表

对于大量数据的列表，使用虚拟化技术：

```jsx
import { FixedSizeList as List } from 'react-window';

function VirtualizedList({ items }) {
  const Row = ({ index, style }) => (
    <div style={style}>
      {items[index].name}
    </div>
  );

  return (
    <List
      height={600}
      itemCount={items.length}
      itemSize={50}
    >
      {Row}
    </List>
  );
}
```

### 2. 防抖和节流

```javascript
// 防抖函数
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

// 节流函数
function throttle(func, limit) {
  let inThrottle;
  return function() {
    const args = arguments;
    const context = this;
    if (!inThrottle) {
      func.apply(context, args);
      inThrottle = true;
      setTimeout(() => inThrottle = false, limit);
    }
  };
}

// 使用示例
const debouncedSearch = debounce((query) => {
  // 执行搜索
}, 300);

const throttledScroll = throttle(() => {
  // 处理滚动事件
}, 100);
```

## 缓存策略

### 1. HTTP 缓存

```javascript
// Service Worker 缓存策略
self.addEventListener('fetch', event => {
  if (event.request.destination === 'image') {
    event.respondWith(
      caches.open('images').then(cache => {
        return cache.match(event.request).then(response => {
          return response || fetch(event.request).then(fetchResponse => {
            cache.put(event.request, fetchResponse.clone());
            return fetchResponse;
          });
        });
      })
    );
  }
});
```

### 2. 内存缓存

```javascript
// 简单的内存缓存实现
class MemoryCache {
  constructor(maxSize = 100) {
    this.cache = new Map();
    this.maxSize = maxSize;
  }

  get(key) {
    if (this.cache.has(key)) {
      // 移到最后（LRU）
      const value = this.cache.get(key);
      this.cache.delete(key);
      this.cache.set(key, value);
      return value;
    }
    return null;
  }

  set(key, value) {
    if (this.cache.size >= this.maxSize) {
      // 删除最旧的项
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }
    this.cache.set(key, value);
  }
}
```

## 监控和测量

### 1. Web Vitals

```javascript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

function sendToAnalytics(metric) {
  // 发送到分析服务
  console.log(metric);
}

getCLS(sendToAnalytics);
getFID(sendToAnalytics);
getFCP(sendToAnalytics);
getLCP(sendToAnalytics);
getTTFB(sendToAnalytics);
```

### 2. Performance API

```javascript
// 测量函数执行时间
function measurePerformance(name, fn) {
  return function(...args) {
    const start = performance.now();
    const result = fn.apply(this, args);
    const end = performance.now();
    console.log(`${name} 执行时间: ${end - start} 毫秒`);
    return result;
  };
}

// 使用示例
const optimizedFunction = measurePerformance('数据处理', processData);
```

## 总结

前端性能优化是一个持续的过程，需要从多个维度进行考虑：

1. **加载性能**：减少资源大小，优化加载策略
2. **运行时性能**：优化算法，减少不必要的计算
3. **用户体验**：提供及时的反馈，优化交互响应
4. **监控测量**：建立性能监控体系，持续优化

记住，性能优化要基于实际数据和用户需求，避免过度优化。